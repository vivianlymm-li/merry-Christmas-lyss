<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            user-select: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        h1 { margin: 0; font-weight: 300; font-size: 1.4rem; letter-spacing: 4px; text-transform: uppercase; }
        p { font-size: 0.9rem; color: #aaa; margin-top: 5px; transition: color 0.3s; }

        #video-input { display: none; } 
        
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2rem; z-index: 20; transition: opacity 0.5s;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <audio id="bgm" loop>
        <source src="https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/bgm.mp3">
    </audio>

    <div id="music-btn">üîá</div>

    <div id="loading" class="loading">LOADING (camera)...</div>

    <div id="ui-layer">
        <h1 id="status-text">merry christmas</h1>
        <p id="instruction-text">üñêÔ∏è OPEN YOUR HAND</p>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- ÈÖçÁΩÆÈ°π ---
        const CONFIG = {
            particleCount: 30000,
            treeHeight: 22,
            baseRadius: 9.5,
            spiralLoops: 6,
            ribbonWidth: 3.6,
            waveFrequency: 3,
            waveAmplitude: 0.6,
            galaxyRadius: 60, 
            colorInside: new THREE.Color('#88ccff'),
            colorOutside: new THREE.Color('#ffffff')
        };
        
        // --- ÂõæÁâáËµÑÊ∫ê ---
        const IMG_FILES = [
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766472557779.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766472592170.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766472609155.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766472641492.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473038443.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473035887.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473053720.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473142070.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473130731.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766573325092.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766573303314.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766573355123.jpg'
        ];

        const BLESSINGS = [
            "Peace", "Blessed", "Joyful", "Lucky",
            "Cheer", "Wonderful", "Healthy", "Cozy",
            "Love", "Wishes", "Marvelous", "Happy"
        ];

        let scene, camera, renderer, composer, controls;
        let treePoints, trunkPoints, twinklePoints; 
        let topStarSpherePoints, topStarRing1Points, topStarRing2Points;
        let photoGroup; 
        let time = 0;

        let targetMorph = 0.0; 
        let currentMorph = 0.0;
        let isHandOpen = false;
        let isPinching = false;
        
        // ÊâãÂäø‰∫§‰∫íÁõ∏ÂÖ≥
        let lastHandX = undefined;
        let currentHandX = 0.5; 
        let rotationVelocity = 0;
        let activeCard = null;

        // Áä∂ÊÄÅÁõ∏ÂÖ≥
        let treeBuildStarted = false; 
        let treeBuildProgress = 0.0; 
        let unlockProgress = 0.0;

        // --- ÁªàÁ´†Ê®°ÂºèÁä∂ÊÄÅ ---
        let finaleActive = false;
        let finaleProgress = 0.0;
        let finaleTriggered = false; 

        // ÊëÑÂÉèÊú∫ÂÖ≥ÈîÆ‰ΩçÁΩÆ
        const treeCamPos = new THREE.Vector3(0, 12, 50);    
        const galaxyCamPos = new THREE.Vector3(0, 12, 25); 
        const centerCamPos = new THREE.Vector3(0, 10, 0);  

        function initScene() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            const ambientLight = new THREE.AmbientLight(0x404040, 2.0);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x88ccff, 1.0); 
            backLight.position.set(-10, 10, -20);
            scene.add(backLight);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(treeCamPos);
            camera.lookAt(0, 10, 0); 

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            renderer.toneMapping = THREE.NoToneMapping; 
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.target.set(0, 10, 0);
            controls.saveState();

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.0;  
            bloomPass.radius = 0.6;
            bloomPass.threshold = 1.01; 

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
        }

        // ËæÖÂä©ÂáΩÊï∞
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function addGalaxyAttribute(geometry, count, radiusScale = 1.0, yCenterOffset = 10) {
            const positions = [];
            const rBase = CONFIG.galaxyRadius * radiusScale;

            for(let i=0; i<count; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(clamp(2 * v - 1, -1, 1));
                const r = rBase * Math.pow(Math.random(), 0.3333); 
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta) + yCenterOffset; 
                const z = r * Math.cos(phi);
                
                positions.push(
                    isNaN(x) ? 0 : x, 
                    isNaN(y) ? 0 : y, 
                    isNaN(z) ? 0 : z
                );
            }
            geometry.setAttribute('aGalaxyPos', new THREE.Float32BufferAttribute(positions, 3));
        }

        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255, 255, 255, 1)');
            g.addColorStop(0.5, 'rgba(100, 160, 255, 0.15)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
            g.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 128, 128);
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                ctx.lineTo(cx + Math.cos(angle) * 60, cy + Math.sin(angle) * 60);
                const midAngle = angle + Math.PI / 4;
                ctx.quadraticCurveTo(cx, cy, cx + Math.cos(midAngle) * 8, cy + Math.sin(midAngle) * 8);
            }
            ctx.closePath(); ctx.fillStyle = '#ffffff'; ctx.fill();
            ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 255, 255, 1.0)'; ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const commonVertexShader = `
            attribute float aSize;
            attribute float aRandom;
            attribute vec3 aColor;
            attribute vec3 aGalaxyPos;
            varying vec3 vColor;
            uniform float uTime;
            uniform float uMorph;
            uniform sampler2D uTexture;
            void main() {
                vColor = aColor;
                vec3 treePos = position;
                if (uMorph < 0.99) {
                    float wave = sin(uTime * 1.5 + treePos.y * 0.5);
                    treePos.y += wave * 0.08;
                }
                float t = uMorph;
                t = t * t * (3.0 - 2.0 * t);
                vec3 pos = mix(treePos, aGalaxyPos, t);
                if (uMorph > 0.01) {
                    pos.x += sin(uTime * 0.5 + aRandom * 10.0) * 0.1 * uMorph;
                    pos.z += cos(uTime * 0.3 + aRandom * 10.0) * 0.1 * uMorph;
                }
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                float baseSize = aSize * (350.0 / -mvPosition.z);
                float twinkle = sin(uTime * 3.0 + aRandom * 10.0);
                float flashSize = baseSize * (0.8 + twinkle * 0.3);
                gl_PointSize = max(2.0, flashSize); 
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const commonFragmentShader = `
            uniform sampler2D uTexture;
            uniform float uOpacity; 
            varying vec3 vColor;
            void main() {
                vec4 texColor = texture2D(uTexture, gl_PointCoord);
                if (texColor.a < 0.05) discard;
                gl_FragColor = vec4(vColor * 2.0, 1.0) * texColor;
                gl_FragColor.a *= uOpacity; 
            }
        `;

        function createTrunk() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const count = 400; 
            const topY = CONFIG.treeHeight * 0.7; const bottomY = -2.0; const totalH = topY - bottomY;
            const baseR = 3; const topR = 0.3;  
            const texture = createSparkleTexture();

            for (let i = 0; i < count; i++) {
                const hRatio = Math.random(); 
                const y = bottomY + hRatio * totalH;
                const currentR = baseR * (1 - hRatio) + topR * hRatio;
                const angle = Math.random() * Math.PI * 2;
                const r = currentR * Math.sqrt(Math.random()) + (Math.random() - 0.5) * 0.8;
                let x = Math.cos(angle) * r;
                let z = Math.sin(angle) * r;
                if (hRatio < 0.15) {
                    const scatter = Math.pow(Math.max(0, 1.0 - hRatio / 0.15), 2.0);
                    const spread = 4.0 * scatter; 
                    x += (Math.random() - 0.5) * spread; z += (Math.random() - 0.5) * spread;
                }
                positions.push(x, y, z);
                const brightness = 2 + Math.random() * 0.1; 
                colors.push(0.1 * brightness, 0.2 * brightness, 0.5 * brightness);
                sizes.push(Math.random() * 1 + 0.6);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3)); 
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));    
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, count, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            trunkPoints = new THREE.Points(geometry, material);
            scene.add(trunkPoints);
        }

        function createTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const texture = createSparkleTexture();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const p = i / CONFIG.particleCount; 
                const angle = p * Math.PI * 2 * CONFIG.spiralLoops;
                const baseRadius = CONFIG.baseRadius * Math.pow(Math.max(0, 1.0 - p), 1.2); 
                const baseHeight = p * CONFIG.treeHeight;
                const wavePhase = angle * 2.5; 
                const currentAmp = CONFIG.waveAmplitude * Math.pow(Math.max(0, 1.0 - p), 1.0);
                const yWave = Math.sin(wavePhase) * currentAmp;
                const rWave = Math.cos(wavePhase) * currentAmp * 0.8;
                let centerY = baseHeight + yWave; let centerR = baseRadius + rWave;
                let widthFactor = p > 0.4 ? 1.0 - (p - 0.4) * 0.5 : 1.0;
                const currentWidth = CONFIG.ribbonWidth * widthFactor;
                const v = Math.random() - 0.5; 
                const twistAmp = 0.5 * Math.pow(Math.max(0, 1.0 - p), 2.0);
                const tiltAngle = Math.cos(wavePhase) * twistAmp;
                const rOffset = v * currentWidth * Math.cos(tiltAngle);
                const yOffset = v * currentWidth * Math.sin(tiltAngle);
                let rFinal = centerR + rOffset; let yFinal = centerY + yOffset;
                const normalizedPos = v + 0.5; 
                yFinal -= Math.pow(normalizedPos, 2) * currentWidth * 0.5;
                yFinal += (Math.random() - 0.5) * 0.15;
                let x = Math.cos(angle) * rFinal; let z = Math.sin(angle) * rFinal;

                let scatterFactor = 0;
                const tailRegion = 0.15;
                if (p < tailRegion) {
                    scatterFactor = Math.pow(Math.max(0, 1.0 - (p / tailRegion)), 2.0);
                    const flare = 0.7 * scatterFactor; 
                    x += Math.cos(angle) * flare; z += Math.sin(angle) * flare;
                    const chaosRadius = 3.0 * scatterFactor; x += (Math.random() - 0.5) * chaosRadius; z += (Math.random() - 0.5) * chaosRadius;
                    yFinal += (Math.random() - 0.5) * scatterFactor * 0.2;
                }
                
                if (isNaN(x)) x = 0;
                if (isNaN(yFinal)) yFinal = 0;
                if (isNaN(z)) z = 0;

                positions.push(x, yFinal, z);

                const mixFactor = Math.random();
                const mixedColor = CONFIG.colorInside.clone().lerp(CONFIG.colorOutside, mixFactor);
                const brightnessFactor = (1.0 - Math.pow(p, 1.8) * 0.6) * 0.6;
                mixedColor.multiplyScalar(brightnessFactor);
                if (scatterFactor > 0) mixedColor.multiplyScalar(1.0 - scatterFactor * 0.7);
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
                
                let size = Math.random() * 1.0 + 0.2; 
                size *= (1.0 - p * 0.3);
                if (scatterFactor > 0) size *= (1.0 - scatterFactor * 0.6);
                sizes.push(size);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, CONFIG.particleCount, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            treePoints = new THREE.Points(geometry, material);
            scene.add(treePoints);
        }

        function createTwinkles() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const count = 500; const texture = createStarTexture();

            for (let i = 0; i < count; i++) {
                const p = Math.random(); const y = p * CONFIG.treeHeight;
                const maxR = CONFIG.baseRadius * (1.0 - p) * 1.2; 
                const r = Math.sqrt(Math.random()) * maxR; const angle = Math.random() * Math.PI * 2;
                let x = Math.cos(angle) * r; let z = Math.sin(angle) * r;
                if (p < 0.1) {
                   const spread = 2.0 * Math.pow(Math.max(0, 1.0 - p / 0.1), 2.0);
                   x += (Math.random() - 0.5) * spread; z += (Math.random() - 0.5) * spread;
                }
                positions.push(x, y, z);
                colors.push(0.9, 0.95, 1.0); 
                sizes.push(Math.random() < 0.05 ? Math.random() * 1.5 + 1.2 : Math.random() * 0.8 + 0.4);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, count, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            twinklePoints = new THREE.Points(geometry, material);
            scene.add(twinklePoints);
        }

        function createTopParticles() {
            const texture = createSparkleTexture();
            const starTexture = createStarTexture();

            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            // 1. Ê†∏ÂøÉÁêÉ
            const sGeo = new THREE.BufferGeometry();
            const sPos = []; const sColors = []; const sSizes = []; const sRandoms = [];
            const sphereCount = 2000; const radius = 1.2;
            for(let i=0; i<sphereCount; i++) {
                const u = Math.random(); const v = Math.random();
                const theta = 2 * Math.PI * u; 
                const phi = Math.acos(clamp(2 * v - 1, -1, 1));
                let rRatio = Math.pow(Math.random(), 0.4); let r = radius * rRatio;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                sPos.push(isNaN(x)?0:x, isNaN(y)?0:y, isNaN(z)?0:z); 
                const distNorm = r / radius; const baseB = 0.5 * (1.0 + distNorm * 0.6);
                sColors.push(baseB * 0.2, baseB * 0.6, baseB * 1.0); 
                sSizes.push(Math.random() * 0.4 + 0.2); sRandoms.push(Math.random());
            }
            sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
            sGeo.setAttribute('aColor', new THREE.Float32BufferAttribute(sColors, 3));
            sGeo.setAttribute('aSize', new THREE.Float32BufferAttribute(sSizes, 1));
            sGeo.setAttribute('aRandom', new THREE.Float32BufferAttribute(sRandoms, 1));
            
            const objY = CONFIG.treeHeight + 1.5;
            const galaxyLocalY = 10 - objY;
            addGalaxyAttribute(sGeo, sphereCount, 1.0, galaxyLocalY);

            topStarSpherePoints = new THREE.Points(sGeo, particleMaterial);
            topStarSpherePoints.position.set(0, objY, 0); 
            scene.add(topStarSpherePoints);

            // 2. ÁéØ
            const ringMaterial = particleMaterial.clone();
            ringMaterial.uniforms.uTexture.value = starTexture;

            const createRing = (radius, tiltX, tiltZ) => {
                const rGeo = new THREE.BufferGeometry();
                const rPos = []; const rColors = []; const rSizes = []; const rRandoms = [];
                const ringCount = 400;
                for(let i=0; i<ringCount; i++) {
                    const angle = (i / ringCount) * Math.PI * 2;
                    const scatterR = (Math.random() - 0.5) + (Math.random() - 0.5); 
                    const r = radius + scatterR * 0.5; 
                    let x = Math.cos(angle) * r; let y = (Math.random() - 0.5) * 0.4; let z = Math.sin(angle) * r;
                    let y1 = y * Math.cos(tiltX) - z * Math.sin(tiltX);
                    let z1 = y * Math.sin(tiltX) + z * Math.cos(tiltX);
                    let x2 = x * Math.cos(tiltZ) - y1 * Math.sin(tiltZ);
                    let y2 = x * Math.sin(tiltZ) + y1 * Math.cos(tiltZ);
                    rPos.push(x2, y2, z1); 
                    const distFactor = 1.0 - Math.abs(scatterR) * 0.8; const brightness = 0.4 * distFactor; 
                    rColors.push(brightness, brightness * 1.1, brightness * 1.2); 
                    rSizes.push(Math.random() * 0.6 + 0.4); rRandoms.push(Math.random());
                }
                rGeo.setAttribute('position', new THREE.Float32BufferAttribute(rPos, 3));
                rGeo.setAttribute('aColor', new THREE.Float32BufferAttribute(rColors, 3));
                rGeo.setAttribute('aSize', new THREE.Float32BufferAttribute(rSizes, 1));
                rGeo.setAttribute('aRandom', new THREE.Float32BufferAttribute(rRandoms, 1));
                addGalaxyAttribute(rGeo, ringCount, 1.0, galaxyLocalY);
                return new THREE.Points(rGeo, ringMaterial);
            };

            topStarRing1Points = createRing(2.0, Math.PI * 0.25, Math.PI * 0.1);
            topStarRing1Points.position.set(0, objY, 0);
            scene.add(topStarRing1Points);

            topStarRing2Points = createRing(2.0, -Math.PI * 0.25, -Math.PI * 0.1);
            topStarRing2Points.position.set(0, objY, 0);
            scene.add(topStarRing2Points);
        }

        function createPhotoGallery() {
            photoGroup = new THREE.Group();
            photoGroup.position.set(0, 10, 0); 
            photoGroup.renderOrder = 999; 
            scene.add(photoGroup);

            const count = 12;
            const radius = 10; 
            
            // --- [‰øÆÊîπÈáçÁÇπ] È´òÊ∏ÖÈÖçÁΩÆ ---
            const RES_SCALE = 4; // ÂàÜËæ®ÁéáÊîæÂ§ß4ÂÄç (300x400 -> 1200x1600)
            
            // Áõ∏Ê°Ü3DÁâ©ÁêÜÂ∞∫ÂØ∏ (‰øùÊåÅ‰∏çÂèòÔºåÂè™ÊîπÁ∫πÁêÜÊ∏ÖÊô∞Â∫¶)
            const frameWidth = 3.5;
            const frameHeight = 4.5;
            const photoWidth = 3.2;
            const photoHeight = 4.2;

            // ÁªòÂà∂ËÉåÊôØÁöÑËæÖÂä©ÂáΩÊï∞ (Â∑≤ÈÄÇÈÖç RES_SCALE)
            const drawBackground = (ctx, isGolden, w, h) => {
                const grd = ctx.createLinearGradient(0, 0, w, h);
                if (isGolden) {
                    grd.addColorStop(0, '#B78727'); 
                    grd.addColorStop(1, '#F7D674'); 
                } else {
                    grd.addColorStop(0, '#001f3f'); 
                    grd.addColorStop(1, '#0072ff'); 
                }
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, w, h);
            };

            // ÂàõÂª∫ËÉåÈù¢Á∫πÁêÜ (Á•ùÁ¶èËØ≠) - Â∑≤ÈÄÇÈÖçÈ´òÊ∏Ö
            const createBackTexture = (text, isGolden = false) => {
                const canvas = document.createElement('canvas');
                // ÊîæÂ§ßÁîªÂ∏ÉÂ∞∫ÂØ∏
                canvas.width = 300 * RES_SCALE; 
                canvas.height = 400 * RES_SCALE;
                const ctx = canvas.getContext('2d');
                
                const w = canvas.width;
                const h = canvas.height;
                
                drawBackground(ctx, isGolden, w, h);
                
                ctx.strokeStyle = isGolden ? "rgba(255, 255, 255, 0.9)" : "rgba(255, 255, 255, 0.8)";
                ctx.lineWidth = 15 * RES_SCALE; // Á∫øÊù°Âä†Á≤ó
                // ÁªòÂà∂ËæπÊ°Ü
                ctx.strokeRect(10 * RES_SCALE, 10 * RES_SCALE, 280 * RES_SCALE, 380 * RES_SCALE);
                
                ctx.fillStyle = isGolden ? "#5C4033" : "white";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = `bold ${40 * RES_SCALE}px Arial`; // Â≠ó‰ΩìÊîæÂ§ß
                
                const words = text.split(' ');
                // ÂùêÊ†á‰ΩçÁΩÆ‰πüÁõ∏Â∫îÊîæÂ§ß
                const cx = 150 * RES_SCALE; 
                const cy1 = 180 * RES_SCALE;
                const cy2 = 230 * RES_SCALE;
                const cyC = 200 * RES_SCALE;

                if (words.length > 2) {
                    ctx.fillText(words.slice(0, Math.ceil(words.length/2)).join(' '), cx, cy1);
                    ctx.fillText(words.slice(Math.ceil(words.length/2)).join(' '), cx, cy2);
                } else {
                    ctx.fillText(text, cx, cyC);
                }
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                return tex;
            };

            const createGoldenBackTexture = (text) => {
                return createBackTexture(text, true);
            };

            // ÁªòÂà∂Âç†‰ΩçÂõæ (Á§ºÁâ©Áõí) - Â∑≤ÈÄÇÈÖçÈ´òÊ∏Ö
            const drawPlaceholder = (ctx) => {
                const w = 300 * RES_SCALE;
                const h = 400 * RES_SCALE;

                ctx.fillStyle = '#C0392B';
                ctx.fillRect(0, 0, w, h); 
                
                ctx.fillStyle = '#F1C40F';
                // ÂùêÊ†áÂíåÂ∞∫ÂØ∏ÈÉΩÈúÄË¶Å‰πò‰ª• RES_SCALE
                ctx.fillRect(135 * RES_SCALE, 0, 30 * RES_SCALE, h); 
                ctx.fillRect(0, 185 * RES_SCALE, w, 30 * RES_SCALE); 
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${32 * RES_SCALE}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText("üéÅ GIFT", 150 * RES_SCALE, 120 * RES_SCALE);
                ctx.font = `${20 * RES_SCALE}px Arial`;
                ctx.fillText("FOR YOU", 150 * RES_SCALE, 160 * RES_SCALE);
            };

            // ÂàõÂª∫Ê≠£Èù¢ÁÖßÁâáÁ∫πÁêÜ - Â∑≤ÈÄÇÈÖçÈ´òÊ∏Ö
            const createFrontTexture = (imgFilename) => {
                const canvas = document.createElement('canvas');
                // Ê†∏ÂøÉÔºöÂ§ßÂπÖÊèêÂçáÁîªÂ∏ÉÂàÜËæ®Áéá
                canvas.width = 300 * RES_SCALE; 
                canvas.height = 400 * RES_SCALE;
                const ctx = canvas.getContext('2d');
                
                // ÈªòËÆ§ÈªëËâ≤ËÉåÊôØ
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const tex = new THREE.CanvasTexture(canvas);
                const img = new Image();
                img.crossOrigin = "Anonymous";
                
                img.onload = () => {
                    // Â∞ÜÂõæÁâáÊãâ‰º∏ÁªòÂà∂Âà∞È´òÊ∏ÖÁîªÂ∏É‰∏ä
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    tex.colorSpace = THREE.SRGBColorSpace; 
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    // ‰ºòÂåñËøáÊª§ËÆæÁΩÆÔºåÈò≤Ê≠¢ËøúÂ§ÑÈó™ÁÉÅ
                    tex.minFilter = THREE.LinearMipMapLinearFilter;
                    tex.magFilter = THREE.LinearFilter;
                    tex.needsUpdate = true;
                };
                
                img.onerror = () => {
                    drawPlaceholder(ctx);
                    tex.needsUpdate = true;
                };
                
                if (!imgFilename) {
                    drawPlaceholder(ctx);
                    tex.needsUpdate = true;
                } else {
                    img.src = imgFilename;
                }
                
                return tex;
            };

            // ‰∏ãÈù¢ÊòØÂàõÂª∫ Mesh ÁöÑÈÄªËæëÔºåÂü∫Êú¨‰øùÊåÅ‰∏çÂèò
            const frameGeometry = new THREE.PlaneGeometry(3.5, 4.5);
            const photoGeometry = new THREE.PlaneGeometry(3.2, 4.2);

            for (let i = 0; i < count; i++) {
                const cardContainer = new THREE.Group();
                const imgFile = IMG_FILES[i % IMG_FILES.length];
                const blessingText = BLESSINGS[i % BLESSINGS.length]; 

                const realPhotoTex = createFrontTexture(imgFile);
                const backTex = createBackTexture(blessingText, false); 

                // 1. Áõ∏Ê°Ü Mesh 
                const frameMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(1.1, 1.1, 1.1),
                    transparent: true,
                    opacity: 0,
                    side: THREE.FrontSide,
                    depthWrite: false
                });
                const frameMesh = new THREE.Mesh(frameGeometry, frameMat);
                frameMesh.position.z = 0.01;

                // 2. ÁÖßÁâá Mesh 
                const photoMat = new THREE.MeshBasicMaterial({
                    map: realPhotoTex,
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0,
                    side: THREE.FrontSide,
                    depthWrite: true, 
                    fog: false 
                });
                const photoMesh = new THREE.Mesh(photoGeometry, photoMat);
                photoMesh.position.z = 0.02; // Âè†Âä†Âú®Áõ∏Ê°Ü‰πã‰∏ä
                
                // 3. Â∞ÅÈù¢ Mesh (Êú™Ëß£ÈîÅÁä∂ÊÄÅÔºåËìùËâ≤ÁâåÈù¢)
                const coverMat = new THREE.MeshBasicMaterial({
                    map: backTex, 
                    color: 0xffffff, 
                    transparent: true,
                    opacity: 0, 
                    side: THREE.FrontSide,
                    depthWrite: false
                });
                const coverMesh = new THREE.Mesh(frameGeometry, coverMat);
                coverMesh.position.z = 0.03; // Âú®ÁÖßÁâá‰πã‰∏ä

                // 4. ËÉåÈù¢ Mesh
                const backMat = new THREE.MeshBasicMaterial({
                    map: backTex, 
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0,
                    side: THREE.FrontSide, 
                    depthWrite: false,
                    fog: false 
                });
                const backMesh = new THREE.Mesh(frameGeometry, backMat);
                backMesh.rotation.y = Math.PI; 
                backMesh.position.z = -0.01;

                cardContainer.add(frameMesh);
                cardContainer.add(photoMesh);
                cardContainer.add(coverMesh); 
                cardContainer.add(backMesh);
                
                // ÂàùÂßãÂåñ coverAlpha = 1.0 (ÂÆåÂÖ®Ë¶ÜÁõñ)
                cardContainer.userData.coverAlpha = 1.0;

                const angle = (i / count) * Math.PI * 2;
                cardContainer.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                
                cardContainer.lookAt(
                    cardContainer.position.x * 2, 
                    0, 
                    cardContainer.position.z * 2
                );

                cardContainer.userData.originPos = cardContainer.position.clone();
                cardContainer.userData.originQuat = cardContainer.quaternion.clone();
                
                const tempLook = cardContainer.clone();
                tempLook.lookAt(0, 2, 0); 
                cardContainer.userData.inwardQuat = tempLook.quaternion.clone();

                cardContainer.userData.originScale = cardContainer.scale.clone();
                cardContainer.userData.randomOffset = Math.random() * 100;
                
                // ‰øùÂ≠òÂºïÁî®‰ª•‰æøÂä®ÁîªÊõ¥Êñ∞
                cardContainer.userData.frameMat = frameMat;
                cardContainer.userData.photoMat = photoMat;
                cardContainer.userData.backMat = backMat;
                cardContainer.userData.coverMat = coverMat; 

                cardContainer.userData.realPhotoTex = realPhotoTex; 
                cardContainer.userData.isRevealed = false; 
                cardContainer.userData.blessingText = blessingText;
                cardContainer.userData.isGolden = false; 

                cardContainer.renderOrder = 10; 

                photoGroup.add(cardContainer);
            }
            
            photoGroup.userData.createGoldenBackTexture = createGoldenBackTexture;
        }

        // Áä∂ÊÄÅËøΩË∏™ÂèòÈáèÔºåÁî®‰∫éËøêÈïúÈÄªËæë
        let isAutoMoving = false;

        // --- 4. Âä®ÁîªÂæ™ÁéØ ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.008;

            // Âü∫Á°ÄÁä∂ÊÄÅÈÄªËæë
            // [‰øÆÊ≠£] ÁßªÈô§Âº∫Âà∂ÂèòÊ†ëÁöÑÈÄªËæë„ÄÇÂΩìÊâãÂº†ÂºÄÊó∂ÔºåÊÄªÊòØÂÖÅËÆ∏Âèò‰∏∫ÊòüÁ©∫ÂΩ¢ÊÄÅÔºàmorph=1.0Ôºâ„ÄÇ
            // ÁªàÁ´†ÁöÑËß¶Âèë‰ºöÊé•ÁÆ°ÊëÑÂÉèÊú∫‰ΩçÁΩÆÔºå‰ΩøÂÖ∂ËøõÂÖ•ÊòüÁ©∫‰∏≠ÂøÉ„ÄÇ
            if (finaleActive) {
                targetMorph = 1.0; 
            } else {
                if (isHandOpen) {
                    targetMorph = 1.0; 
                } else {
                    targetMorph = 0.0;
                }
                
                if (isPinching) targetMorph = 1.0;
            }

            currentMorph += (targetMorph - currentMorph) * 0.05; 

            // ÊòüÁ©∫ÊóãËΩ¨ÈÄªËæë
            if (currentMorph > 0.01) {
                const galaxyRotSpeed = 0.0005; 
                if(treePoints) treePoints.rotation.y += galaxyRotSpeed;
                if(trunkPoints) trunkPoints.rotation.y += galaxyRotSpeed;
                if(twinklePoints) twinklePoints.rotation.y += galaxyRotSpeed;
                if(topStarSpherePoints) topStarSpherePoints.rotation.y += galaxyRotSpeed;
            }

            const updateUniforms = (obj) => {
                if(obj && obj.material && obj.material.uniforms && obj.material.uniforms.uMorph) {
                    obj.material.uniforms.uMorph.value = currentMorph;
                    obj.material.uniforms.uTime.value = time;
                }
            };
            updateUniforms(treePoints);
            updateUniforms(trunkPoints);
            updateUniforms(twinklePoints);
            updateUniforms(topStarSpherePoints);
            updateUniforms(topStarRing1Points);
            updateUniforms(topStarRing2Points);

            let revealedCount = 0;
            if (photoGroup) {
                photoGroup.children.forEach(c => {
                    if (c.userData.isRevealed) revealedCount++;
                });
            }
            unlockProgress = revealedCount / 12.0;
            
            // [‰øÆÊîπ] ÁªàÁ´†Ëß¶ÂèëÈÄªËæëÔºöÂ¢ûÂä† isHandOpen Âà§Êñ≠
            // Âè™ÊúâÂΩìÂÖ®ÈÉ®Ëß£ÈîÅ ‰∏î Âº†ÂºÄÊâãÊéåÊó∂ÔºåËß¶ÂèëÁªàÁ´†
            // Update: ‰øÆÊîπ‰∏∫Âè™Ë¶ÅËß£ÈîÅ‰∏îÂº†ÊâãÔºåÂ∞±ÊøÄÊ¥ª„ÄÇ‰∏ç‰ΩøÁî® !finaleTriggered ÈîÅÂÆö
            if (unlockProgress >= 0.99 && activeCard === null && isHandOpen) {
                if (!treeBuildStarted) {
                    treeBuildStarted = true; 
                }
                finaleActive = true; 
                // finaleTriggered = true; // ÁßªÈô§Ê≠§Ë°åÔºåÂÖÅËÆ∏ÈáçÂ§çËß¶Âèë
            }
            
            if (finaleActive) {
                finaleProgress += (1.0 - finaleProgress) * 0.02; 
            } else {
                finaleProgress += (0.0 - finaleProgress) * 0.05; 
            }
            
            if (treeBuildStarted) {
                treeBuildProgress += 0.005; 
                if (treeBuildProgress > 1.0) treeBuildProgress = 1.0;
            } else {
                treeBuildProgress = 0.0;
            }

            const finaleHideFactor = Math.max(0, 1.0 - finaleProgress * 2.0);
            
            if (trunkPoints && trunkPoints.material.uniforms) {
                 trunkPoints.material.uniforms.uOpacity.value = finaleHideFactor;
            }

            if (photoGroup) {
                photoGroup.updateMatrixWorld();

                if (activeCard) {
                    rotationVelocity *= 0.5; 
                } else {
                    let baseSpeed = 0.0009;
                    if (finaleActive) {
                        baseSpeed = 0.002; 
                    }
                    
                    let edgeForce = 0;
                    if (isHandOpen && !isPinching) { 
                        if (currentHandX < 0.15) {
                            if (finaleActive) {
                                edgeForce = 0.0025;
                            } else {
                                edgeForce = -0.0025; 
                            }
                        } else if (currentHandX > 0.85) {
                            if (finaleActive) {
                                edgeForce = -0.0025;
                            } else {
                                edgeForce = 0.0025; 
                            }
                        }
                    }

                    rotationVelocity *= 0.95; 
                    rotationVelocity += edgeForce;
                    
                    if (Math.abs(rotationVelocity) < 0.0001) {
                         photoGroup.rotation.y -= baseSpeed;
                    } else {
                         photoGroup.rotation.y += rotationVelocity;
                    }
                }

                photoGroup.children.forEach(cardContainer => {
                    // ÂÖ®Â±ÄÊ∑°ÂÖ•ËøõÂ∫¶ (Hand Open Ëß¶Âèë)
                    let targetOpacity = (currentMorph - 0.5) * 2.0;
                    targetOpacity = Math.max(0, Math.min(1, targetOpacity));
                    
                    // 1. ËÆæÁΩÆËæπÊ°ÜÂíåËÉåÈù¢ÁöÑ‰∏çÈÄèÊòéÂ∫¶ (Ë∑üÈöèÂÖ®Â±Ä)
                    if (cardContainer.userData.frameMat) cardContainer.userData.frameMat.opacity = targetOpacity;
                    if (cardContainer.userData.backMat) cardContainer.userData.backMat.opacity = targetOpacity;
                    
                    // 2. Â∞ÅÈù¢‰∏éÁÖßÁâáÁöÑ‰∫§ÂèâÊ∑°ÂÖ•ÈÄªËæë (Cross-Fade)
                    if (cardContainer.userData.coverMat && cardContainer.userData.photoMat) {
                        // ÁõÆÊ†á Reveal Áä∂ÊÄÅ (0=Êè≠ÂºÄ/ÁÖßÁâáÂèØËßÅ, 1=Ë¶ÜÁõñ/Â∞ÅÈù¢ÂèØËßÅ)
                        let targetRevealAlpha = cardContainer.userData.isRevealed ? 0.0 : 1.0;
                        
                        // Âπ≥ÊªëËøáÊ∏°
                        cardContainer.userData.coverAlpha = THREE.MathUtils.lerp(
                            cardContainer.userData.coverAlpha,
                            targetRevealAlpha,
                            0.1
                        );
                        
                        // [ÂÖ≥ÈîÆ‰øÆÂ§ç] Â∞ÅÈù¢‰∏çÈÄèÊòéÂ∫¶ = ÂÖ®Â±Ä‰∏çÈÄèÊòéÂ∫¶ * Ë¶ÜÁõñÁä∂ÊÄÅ
                        cardContainer.userData.coverMat.opacity = targetOpacity * cardContainer.userData.coverAlpha;
                        
                        // [ÂÖ≥ÈîÆ‰øÆÂ§ç] ÁÖßÁâá‰∏çÈÄèÊòéÂ∫¶ = ÂÖ®Â±Ä‰∏çÈÄèÊòéÂ∫¶ * (1 - Ë¶ÜÁõñÁä∂ÊÄÅ)
                        // ËøôÊ†∑ÂΩì Cover Â≠òÂú®Êó∂ (coverAlpha=1), Photo Â∞±‰∏çÊòæÁ§∫ (opacity=0), ÈÅøÂÖçÈÄèËßÜÈáçÂè†
                        let photoVis = 1.0 - cardContainer.userData.coverAlpha;
                        // Èí≥Âà∂ÔºåÈò≤Ê≠¢ lerp ËøáÂÜ≤ÂØºËá¥Ë¥üÂÄº
                        photoVis = Math.max(0, Math.min(1, photoVis));
                        cardContainer.userData.photoMat.opacity = targetOpacity * photoVis;

                        // ‰ºòÂåñÊ∑±Â∫¶ÂÜôÂÖ•
                        cardContainer.userData.coverMat.depthWrite = cardContainer.userData.coverMat.opacity > 0.1;
                    }

                    if (cardContainer === activeCard) {
                        cardContainer.renderOrder = 9999;
                        
                        if (cardContainer.userData.frameMat) {
                            cardContainer.userData.frameMat.depthTest = false;
                            cardContainer.userData.frameMat.depthWrite = false;
                            cardContainer.userData.frameMat.opacity = 1.0;
                        }
                        if (cardContainer.userData.photoMat) {
                            cardContainer.userData.photoMat.depthTest = false;
                            cardContainer.userData.photoMat.depthWrite = false;
                            cardContainer.userData.photoMat.opacity = 1.0;
                        }
                        if (cardContainer.userData.backMat) {
                            cardContainer.userData.backMat.depthTest = false;
                            cardContainer.userData.backMat.depthWrite = false;
                            cardContainer.userData.backMat.opacity = 1.0;
                        }
                        if (cardContainer.userData.coverMat) { 
                            cardContainer.userData.coverMat.depthTest = false;
                            // Â∞ÅÈù¢Ê†πÊçÆ reveal Áä∂ÊÄÅÂÜ≥ÂÆöÈÄèÊòéÂ∫¶ÔºåË¢´ÁÇπÂáªÊó∂ reveal=true, coverAlpha->0
                            cardContainer.userData.coverMat.opacity = cardContainer.userData.coverAlpha; 
                        }

                        if (!cardContainer.userData.isRevealed) {
                            cardContainer.userData.isRevealed = true;
                            
                            if (!cardContainer.userData.isGolden) {
                                cardContainer.userData.isGolden = true;
                                const goldTex = photoGroup.userData.createGoldenBackTexture(cardContainer.userData.blessingText);
                                cardContainer.userData.backMat.map = goldTex;
                                cardContainer.userData.backMat.needsUpdate = true;
                            }
                        }

                        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        const targetWorldPos = camera.position.clone().add(forward.multiplyScalar(14));
                        const targetLocalPos = photoGroup.worldToLocal(targetWorldPos.clone());

                        const groupWorldQuat = new THREE.Quaternion();
                        photoGroup.getWorldQuaternion(groupWorldQuat);
                        const groupInv = groupWorldQuat.invert();
                        const targetQuat = groupInv.multiply(camera.quaternion);

                        cardContainer.position.lerp(targetLocalPos, 0.1);
                        cardContainer.quaternion.slerp(targetQuat, 0.2);
                        
                        const pulse = 1.0 + Math.sin(time * 3.0) * 0.05; 
                        const targetScale = new THREE.Vector3(3.2 * pulse, 3.2 * pulse, 3.2 * pulse);
                        cardContainer.scale.lerp(targetScale, 0.1);

                    } else {
                        // [‰øÆÊîπ] ÂΩí‰ΩçÊó∂ÁöÑÂ±ÇÁ∫ßÈÄªËæë
                        // Â¶ÇÊûúË∑ùÁ¶ªÁõÆÊ†á‰ΩçÁΩÆËæÉËøú(Ê≠£Âú®È£ûË°åÂΩí‰Ωç‰∏≠)Ôºå‰øùÊåÅËæÉÈ´òÂ±ÇÁ∫ßÈò≤Ê≠¢Á©øÊ®°
                        const distToTarget = cardContainer.position.distanceTo(cardContainer.userData.originPos);
                        if (distToTarget > 0.5) {
                            cardContainer.renderOrder = 5000; // ÊØîÈÄâ‰∏≠Áä∂ÊÄÅ(9999)‰ΩéÔºå‰ΩÜÊØîÈùôÊ≠¢Áä∂ÊÄÅ(10)È´ò
                        } else {
                            cardContainer.renderOrder = 10;
                        }
                        
                        if (cardContainer.userData.frameMat) {
                            cardContainer.userData.frameMat.depthTest = true;
                            cardContainer.userData.frameMat.depthWrite = false;
                        }
                        if (cardContainer.userData.photoMat) {
                            cardContainer.userData.photoMat.depthTest = true;
                            cardContainer.userData.photoMat.depthWrite = false;
                        }
                        if (cardContainer.userData.backMat) {
                            cardContainer.userData.backMat.depthTest = true;
                            cardContainer.userData.backMat.depthWrite = false;
                        }
                        if (cardContainer.userData.coverMat) {
                            cardContainer.userData.coverMat.depthTest = true;
                        }

                        cardContainer.position.lerp(cardContainer.userData.originPos, 0.05);
                        
                        const floatY = Math.sin(time * 1.5 + cardContainer.userData.randomOffset) * 0.2;
                        const targetPosWithFloat = cardContainer.userData.originPos.clone();
                        targetPosWithFloat.y += floatY;
                        cardContainer.position.lerp(targetPosWithFloat, 0.05);

                        if (finaleProgress > 0.01) {
                            const currentQ = cardContainer.userData.originQuat.clone();
                            const targetQ = cardContainer.userData.inwardQuat.clone();
                            currentQ.slerp(targetQ, finaleProgress); 
                            cardContainer.quaternion.slerp(currentQ, 0.05);
                        } else {
                            cardContainer.quaternion.slerp(cardContainer.userData.originQuat, 0.05);
                        }
                        
                        cardContainer.scale.lerp(cardContainer.userData.originScale, 0.05);
                    }
                });
            }

            if (isHandOpen || finaleActive || currentMorph > 0.001 || finaleProgress > 0.001) {
                isAutoMoving = true;
            }

            if (isAutoMoving) {
                controls.enabled = false;

                let targetCamPos = treeCamPos.clone(); 
                
                targetCamPos.lerp(galaxyCamPos, currentMorph);
                
                if (finaleProgress > 0.001) {
                    targetCamPos.lerp(centerCamPos, finaleProgress);
                }

                camera.position.copy(targetCamPos);
                camera.lookAt(0, 10, 0);

                if (!isHandOpen && !finaleActive && currentMorph < 0.001 && finaleProgress < 0.001) {
                    isAutoMoving = false;
                    controls.enabled = true;
                    controls.target.set(0, 10, 0); 
                    controls.update();
                }
            } else {
                controls.enabled = true;
                controls.update();
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const statusText = document.getElementById('status-text');
            const instructionText = document.getElementById('instruction-text');
            const loading = document.getElementById('loading');

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            cameraUtils.start()
                .then(() => {
                    loading.style.opacity = 0;
                    setTimeout(() => loading.style.display = 'none', 500);
                    console.log("Camera started");
                })
                .catch(err => {
                    console.error(err);
                    loading.innerText = "ÊëÑÂÉèÂ§¥ÂêØÂä®Â§±Ë¥• (ËØ∑ÂÖÅËÆ∏ÊùÉÈôê)";
                    statusText.innerText = "Camera Error";
                });
            
            function onResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const wrist = landmarks[0];
                    const thumbTip = landmarks[4];
                    
                    const currX = wrist.x;
                    currentHandX = currX;

                    if (typeof lastHandX !== 'undefined') {
                        const delta = currX - lastHandX;
                        if (!activeCard && isHandOpen) {
                            if (finaleActive) {
                                rotationVelocity -= delta * 0.35; 
                            } else {
                                rotationVelocity += delta * 0.35; 
                            }
                        }
                    }
                    lastHandX = currX;

                    const tips = [4, 8, 12, 16, 20]; 
                    let avgDist = 0;
                    tips.forEach(idx => {
                        const tip = landmarks[idx];
                        const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                        avgDist += d;
                    });
                    avgDist /= 5;
                    
                    const indexTip = landmarks[8];
                    const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                    const PINCH_THRESHOLD = 0.05; 
                    const OPEN_THRESHOLD = 0.25;  

                    const otherTips = [8, 12, 16, 20];
                    let fiveFingerDist = 0;
                    otherTips.forEach(id => {
                        const t = landmarks[id];
                        fiveFingerDist += Math.sqrt(Math.pow(t.x - thumbTip.x, 2) + Math.pow(t.y - thumbTip.y, 2));
                    });
                    fiveFingerDist /= 4;
                    const isFiveFingerPinch = fiveFingerDist < 0.1; 

                    if (pinchDist < PINCH_THRESHOLD) {
                        if (isFiveFingerPinch) {
                             isPinching = false;
                             isHandOpen = false; 
                             activeCard = null;
                             
                             finaleActive = false;

                             statusText.innerText = "MERRY CHRISTMAS";
                             statusText.style.color = "#ffffff";
                             instructionText.innerText = "üñêÔ∏è OPEN YOUR HAND";
                             
                        } else {
                            isPinching = true;
                            isHandOpen = true; 
                            statusText.innerText = "üéäüéÑü•≥üéÑüéä";
                            statusText.style.color = "#ffcc00";
                            instructionText.innerText = "open your hand to continue";

                            if (!activeCard && photoGroup) {
                                let bestMetric = finaleActive ? -Infinity : Infinity; 
                                let closest = null;
                                
                                const camDir = new THREE.Vector3();
                                camera.getWorldDirection(camDir);
                                
                                photoGroup.children.forEach(group => {
                                    const worldPos = new THREE.Vector3();
                                    group.getWorldPosition(worldPos);
                                    
                                    if (finaleActive) {
                                        const vecToCard = worldPos.clone().sub(camera.position).normalize();
                                        const dot = camDir.dot(vecToCard);
                                        if (dot > bestMetric) {
                                            bestMetric = dot;
                                            closest = group;
                                        }
                                    } else {
                                        const dist = worldPos.distanceTo(camera.position);
                                        if (dist < bestMetric) {
                                            bestMetric = dist;
                                            closest = group;
                                        }
                                    }
                                });
                                if (closest) activeCard = closest;
                            }
                        }

                    } else if (avgDist > OPEN_THRESHOLD) {
                        isPinching = false;
                        isHandOpen = true; 
                        activeCard = null;
                        
                        if (finaleActive) {
                            statusText.innerText = "ü©µüíôüíõ MERRY CHRISTMAS üíõüíôü©µ";
                            statusText.style.color = "#ff88cc";
                            instructionText.innerText = "ü§èpick any photo you want ‚úäÔ∏èmake a fist to exit";
                        } else {
                            statusText.innerText = "GIFT TIME ‚úß*ÔΩ°Ÿ©(Àä·óúÀã*)Ÿà‚úß*ÔΩ°";
                            statusText.style.color = "#88ccff";
                            instructionText.innerText = "‚ÜîÔ∏èmove your hand and ü§èpick any photo you want";
                        }

                    } else if (isFiveFingerPinch) {
                        isPinching = false;
                        isHandOpen = false; 
                        activeCard = null;
                        
                        finaleActive = false;

                        statusText.innerText = "MERRY CHRISTMAS";
                        statusText.style.color = "#ffffff";
                        instructionText.innerText = "üñêÔ∏è OPEN YOUR HAND";
                        
                    } else {
                        isPinching = false;
                        activeCard = null;
                    }
                } else {
                    isPinching = false;
                    activeCard = null;
                    lastHandX = undefined; 
                    currentHandX = 0.5; // Reset
                    
                    if (isHandOpen) {
                    } else {
                         statusText.innerText = "MERRY CHRISTMAS";
                         statusText.style.color = "#ffffff";
                    }
                }
            }
        }

        initScene();
        createTrunk();
        createTree();
        createTwinkles(); 
        createTopParticles();
        createPhotoGallery(); 
        animate();
        
        setTimeout(initMediaPipe, 1000);

        // --- Êñ∞Â¢ûÔºöËÉåÊôØÈü≥‰πêÊéßÂà∂ÈÄªËæë ---
        const bgm = document.getElementById('bgm');
        const musicBtn = document.getElementById('music-btn');
        let isMusicPlaying = false;

        // ËÆæÁΩÆÈü≥Èáè (0.0 ~ 1.0)
        bgm.volume = 0.4; 

        function toggleMusic() {
            if (bgm.paused) {
                bgm.play().then(() => {
                    isMusicPlaying = true;
                    musicBtn.innerText = "üéµ"; // Êí≠ÊîæÂõæÊ†á
                    musicBtn.style.animation = "spin 3s linear infinite"; // ÂèØÈÄâÔºöÂä†‰∏™ÊóãËΩ¨Âä®Áîª
                }).catch(e => console.log("Á≠âÂæÖ‰∫§‰∫í..."));
            } else {
                bgm.pause();
                isMusicPlaying = false;
                musicBtn.innerText = "üîá"; // ÈùôÈü≥ÂõæÊ†á
                musicBtn.style.animation = "none";
            }
        }

        musicBtn.addEventListener('click', toggleMusic);

        // Â∞ùËØïËá™Âä®Êí≠Êîæ (Â§ßÈÉ®ÂàÜÊµèËßàÂô®‰ºöÊã¶Êà™ÔºåÊâÄ‰ª•ÈúÄË¶Å‰∏ãÈù¢ÁöÑ click ÁõëÂê¨)
        bgm.play().then(() => {
            isMusicPlaying = true;
            musicBtn.innerText = "üéµ";
        }).catch(() => {
            console.log("ÊµèËßàÂô®ÈòªÊ≠¢‰∫ÜËá™Âä®Êí≠ÊîæÔºåÁ≠âÂæÖÁî®Êà∑ÁÇπÂáª...");
            // ÁõëÂê¨‰ªªÊÑèÁÇπÂáªÔºå‰∏ÄÊó¶Áî®Êà∑ÁÇπ‰∫ÜÂ±èÂπïÔºåÂ∞±ÂºÄÂßãÊí≠Êîæ
            document.addEventListener('click', () => {
                if (!isMusicPlaying) toggleMusic();
            }, { once: true }); // Âè™ÊâßË°å‰∏ÄÊ¨°
        });

    </script>
</body>

</html>


