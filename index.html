<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            user-select: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        h1 { margin: 0; font-weight: 300; font-size: 1.4rem; letter-spacing: 4px; text-transform: uppercase; }
        p { font-size: 0.9rem; color: #aaa; margin-top: 5px; transition: color 0.3s; }

        #video-input { display: none; } 
        
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2rem; z-index: 20; transition: opacity 0.5s;
        }

        #music-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 50;
            font-size: 2rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
            user-select: none;
        }
        #music-btn:hover { opacity: 1; }

        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* --- Êñ∞Â¢ûÔºöÂêØÂä®ÈÅÆÁΩ©Â±ÇÊ†∑Âºè --- */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.8s ease;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            letter-spacing: 3px;
            color: #fff;
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 30px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
            margin-top: 20px;
        }

        #start-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <audio id="bgm" loop>
        <source src="https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/alliwantfor.mp3">
    </audio>

    <div id="start-screen">
        <h1 style="color:white; margin-bottom:20px; font-size: 2rem;">Merry Christmas</h1>
        <p style="color:#aaa; font-size:0.9rem;">Interact to start the magic</p>
        <button id="start-btn">ENTER EXPERIENCE</button>
    </div>

    <div id="music-btn">üîá</div>

    <div id="loading" class="loading">LOADING (camera)...</div>

    <div id="ui-layer">
        <h1 id="status-text">merry christmas</h1>
        <p id="instruction-text">üñêÔ∏è OPEN YOUR HAND</p>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- ÈÖçÁΩÆÈ°π ---
        const CONFIG = {
            particleCount: 30000,
            treeHeight: 22,
            baseRadius: 9.5,
            spiralLoops: 6,
            ribbonWidth: 3.6,
            waveFrequency: 3,
            waveAmplitude: 0.6,
            galaxyRadius: 60, 
            colorInside: new THREE.Color('#88ccff'),
            colorOutside: new THREE.Color('#ffffff')
        };
        
        // --- ÂõæÁâáËµÑÊ∫ê ---
        const IMG_FILES = [
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766472557779.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766472592170.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766472609155.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766472641492.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473038443.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473035887.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473053720.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473142070.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766473130731.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766573325092.jpg',
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766573303314.jpg', 
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/mmexport1766573355123.jpg'
        ];

        const BLESSINGS = [
            "Peace", "Blessed", "Joyful", "Lucky",
            "Cheer", "Wonderful", "Healthy", "Cozy",
            "Love", "Wishes", "Marvelous", "Happy"
        ];

        let scene, camera, renderer, composer, controls;
        let treePoints, trunkPoints, twinklePoints; 
        let topStarSpherePoints, topStarRing1Points, topStarRing2Points;
        let photoGroup; 
        let time = 0;

        let targetMorph = 0.0; 
        let currentMorph = 0.0;
        let isHandOpen = false;
        let isPinching = false;
        
        // ÊâãÂäø‰∫§‰∫íÁõ∏ÂÖ≥
        let lastHandX = undefined;
        let currentHandX = 0.5; 
        let rotationVelocity = 0;
        let activeCard = null;

        // Áä∂ÊÄÅÁõ∏ÂÖ≥
        let treeBuildStarted = false; 
        let treeBuildProgress = 0.0; 
        let unlockProgress = 0.0;

        // --- ÁªàÁ´†Ê®°ÂºèÁä∂ÊÄÅ ---
        let finaleActive = false;
        let finaleProgress = 0.0;

        // ÊëÑÂÉèÊú∫ÂÖ≥ÈîÆ‰ΩçÁΩÆ
        const treeCamPos = new THREE.Vector3(0, 12, 50);    
        const galaxyCamPos = new THREE.Vector3(0, 12, 25); 
        const centerCamPos = new THREE.Vector3(0, 10, 0);  

        function initScene() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            const ambientLight = new THREE.AmbientLight(0x404040, 2.0);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x88ccff, 1.0); 
            backLight.position.set(-10, 10, -20);
            scene.add(backLight);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(treeCamPos);
            camera.lookAt(0, 10, 0); 

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            renderer.toneMapping = THREE.NoToneMapping; 
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.target.set(0, 10, 0);
            controls.saveState();

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.0;  
            bloomPass.radius = 0.6;
            bloomPass.threshold = 1.01; 

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
        }

        // ËæÖÂä©ÂáΩÊï∞
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function addGalaxyAttribute(geometry, count, radiusScale = 1.0, yCenterOffset = 10) {
            const positions = [];
            const rBase = CONFIG.galaxyRadius * radiusScale;

            for(let i=0; i<count; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(clamp(2 * v - 1, -1, 1));
                const r = rBase * Math.pow(Math.random(), 0.3333); 
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta) + yCenterOffset; 
                const z = r * Math.cos(phi);
                
                positions.push(
                    isNaN(x) ? 0 : x, 
                    isNaN(y) ? 0 : y, 
                    isNaN(z) ? 0 : z
                );
            }
            geometry.setAttribute('aGalaxyPos', new THREE.Float32BufferAttribute(positions, 3));
        }

        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255, 255, 255, 1)');
            g.addColorStop(0.5, 'rgba(100, 160, 255, 0.15)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
            g.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 128, 128);
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                ctx.lineTo(cx + Math.cos(angle) * 60, cy + Math.sin(angle) * 60);
                const midAngle = angle + Math.PI / 4;
                ctx.quadraticCurveTo(cx, cy, cx + Math.cos(midAngle) * 8, cy + Math.sin(midAngle) * 8);
            }
            ctx.closePath(); ctx.fillStyle = '#ffffff'; ctx.fill();
            ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 255, 255, 1.0)'; ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const commonVertexShader = `
            attribute float aSize;
            attribute float aRandom;
            attribute vec3 aColor;
            attribute vec3 aGalaxyPos;
            varying vec3 vColor;
            uniform float uTime;
            uniform float uMorph;
            uniform sampler2D uTexture;
            void main() {
                vColor = aColor;
                vec3 treePos = position;
                if (uMorph < 0.99) {
                    float wave = sin(uTime * 1.5 + treePos.y * 0.5);
                    treePos.y += wave * 0.08;
                }
                float t = uMorph;
                t = t * t * (3.0 - 2.0 * t);
                vec3 pos = mix(treePos, aGalaxyPos, t);
                if (uMorph > 0.01) {
                    pos.x += sin(uTime * 0.5 + aRandom * 10.0) * 0.1 * uMorph;
                    pos.z += cos(uTime * 0.3 + aRandom * 10.0) * 0.1 * uMorph;
                }
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                float baseSize = aSize * (350.0 / -mvPosition.z);
                float twinkle = sin(uTime * 3.0 + aRandom * 10.0);
                float flashSize = baseSize * (0.8 + twinkle * 0.3);
                gl_PointSize = max(2.0, flashSize); 
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const commonFragmentShader = `
            uniform sampler2D uTexture;
            uniform float uOpacity; 
            varying vec3 vColor;
            void main() {
                vec4 texColor = texture2D(uTexture, gl_PointCoord);
                if (texColor.a < 0.05) discard;
                gl_FragColor = vec4(vColor * 2.0, 1.0) * texColor;
                gl_FragColor.a *= uOpacity; 
            }
        `;

        function createTrunk() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const count = 400; 
            const topY = CONFIG.treeHeight * 0.7; const bottomY = -2.0; const totalH = topY - bottomY;
            const baseR = 3; const topR = 0.3;  
            const texture = createSparkleTexture();

            for (let i = 0; i < count; i++) {
                const hRatio = Math.random(); 
                const y = bottomY + hRatio * totalH;
                const currentR = baseR * (1 - hRatio) + topR * hRatio;
                const angle = Math.random() * Math.PI * 2;
                const r = currentR * Math.sqrt(Math.random()) + (Math.random() - 0.5) * 0.8;
                let x = Math.cos(angle) * r;
                let z = Math.sin(angle) * r;
                if (hRatio < 0.15) {
                    const scatter = Math.pow(Math.max(0, 1.0 - hRatio / 0.15), 2.0);
                    const spread = 4.0 * scatter; 
                    x += (Math.random() - 0.5) * spread; z += (Math.random() - 0.5) * spread;
                }
                positions.push(x, y, z);
                const brightness = 2 + Math.random() * 0.1; 
                colors.push(0.1 * brightness, 0.2 * brightness, 0.5 * brightness);
                sizes.push(Math.random() * 1 + 0.6);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3)); 
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));     
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, count, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            trunkPoints = new THREE.Points(geometry, material);
            scene.add(trunkPoints);
        }

        function createTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const texture = createSparkleTexture();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const p = i / CONFIG.particleCount; 
                const angle = p * Math.PI * 2 * CONFIG.spiralLoops;
                const baseRadius = CONFIG.baseRadius * Math.pow(Math.max(0, 1.0 - p), 1.2); 
                const baseHeight = p * CONFIG.treeHeight;
                const wavePhase = angle * 2.5; 
                const currentAmp = CONFIG.waveAmplitude * Math.pow(Math.max(0, 1.0 - p), 1.0);
                const yWave = Math.sin(wavePhase) * currentAmp;
                const rWave = Math.cos(wavePhase) * currentAmp * 0.8;
                let centerY = baseHeight + yWave; let centerR = baseRadius + rWave;
                let widthFactor = p > 0.4 ? 1.0 - (p - 0.4) * 0.5 : 1.0;
                const currentWidth = CONFIG.ribbonWidth * widthFactor;
                const v = Math.random() - 0.5; 
                const twistAmp = 0.5 * Math.pow(Math.max(0, 1.0 - p), 2.0);
                const tiltAngle = Math.cos(wavePhase) * twistAmp;
                const rOffset = v * currentWidth * Math.cos(tiltAngle);
                const yOffset = v * currentWidth * Math.sin(tiltAngle);
                let rFinal = centerR + rOffset; let yFinal = centerY + yOffset;
                const normalizedPos = v + 0.5; 
                yFinal -= Math.pow(normalizedPos, 2) * currentWidth * 0.5;
                yFinal += (Math.random() - 0.5) * 0.15;
                let x = Math.cos(angle) * rFinal; let z = Math.sin(angle) * rFinal;

                let scatterFactor = 0;
                const tailRegion = 0.15;
                if (p < tailRegion) {
                    scatterFactor = Math.pow(Math.max(0, 1.0 - (p / tailRegion)), 2.0);
                    const flare = 0.7 * scatterFactor; 
                    x += Math.cos(angle) * flare; z += Math.sin(angle) * flare;
                    const chaosRadius = 3.0 * scatterFactor; x += (Math.random() - 0.5) * chaosRadius; z += (Math.random() - 0.5) * chaosRadius;
                    yFinal += (Math.random() - 0.5) * scatterFactor * 0.2;
                }
                
                if (isNaN(x)) x = 0;
                if (isNaN(yFinal)) yFinal = 0;
                if (isNaN(z)) z = 0;

                positions.push(x, yFinal, z);

                const mixFactor = Math.random();
                const mixedColor = CONFIG.colorInside.clone().lerp(CONFIG.colorOutside, mixFactor);
                const brightnessFactor = (1.0 - Math.pow(p, 1.8) * 0.6) * 0.6;
                mixedColor.multiplyScalar(brightnessFactor);
                if (scatterFactor > 0) mixedColor.multiplyScalar(1.0 - scatterFactor * 0.7);
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
                
                let size = Math.random() * 1.0 + 0.2; 
                size *= (1.0 - p * 0.3);
                if (scatterFactor > 0) size *= (1.0 - scatterFactor * 0.6);
                sizes.push(size);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, CONFIG.particleCount, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            treePoints = new THREE.Points(geometry, material);
            scene.add(treePoints);
        }

        function createTwinkles() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const count = 500; const texture = createStarTexture();

            for (let i = 0; i < count; i++) {
                const p = Math.random(); const y = p * CONFIG.treeHeight;
                const maxR = CONFIG.baseRadius * (1.0 - p) * 1.2; 
                const r = Math.sqrt(Math.random()) * maxR; const angle = Math.random() * Math.PI * 2;
                let x = Math.cos(angle) * r; let z = Math.sin(angle) * r;
                if (p < 0.1) {
                   const spread = 2.0 * Math.pow(Math.max(0, 1.0 - p / 0.1), 2.0);
                   x += (Math.random() - 0.5) * spread; z += (Math.random() - 0.5) * spread;
                }
                positions.push(x, y, z);
                colors.push(0.9, 0.95, 1.0); 
                sizes.push(Math.random() < 0.05 ? Math.random() * 1.5 + 1.2 : Math.random() * 0.8 + 0.4);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, count, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            twinklePoints = new THREE.Points(geometry, material);
            scene.add(twinklePoints);
        }

        function createTopParticles() {
            const texture = createSparkleTexture();
            const starTexture = createStarTexture();

            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            // 1. Ê†∏ÂøÉÁêÉ
            const sGeo = new THREE.BufferGeometry();
            const sPos = []; const sColors = []; const sSizes = []; const sRandoms = [];
            const sphereCount = 2000; const radius = 1.2;
            for(let i=0; i<sphereCount; i++) {
                const u = Math.random(); const v = Math.random();
                const theta = 2 * Math.PI * u; 
                const phi = Math.acos(clamp(2 * v - 1, -1, 1));
                let rRatio = Math.pow(Math.random(), 0.4); let r = radius * rRatio;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                sPos.push(isNaN(x)?0:x, isNaN(y)?0:y, isNaN(z)?0:z); 
                const distNorm = r / radius; const baseB = 0.5 * (1.0 + distNorm * 0.6);
                sColors.push(baseB * 0.2, baseB * 0.6, baseB * 1.0); 
                sSizes.push(Math.random() * 0.4 + 0.2); sRandoms.push(Math.random());
            }
            sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
            sGeo.setAttribute('aColor', new THREE.Float32BufferAttribute(sColors, 3));
            sGeo.setAttribute('aSize', new THREE.Float32BufferAttribute(sSizes, 1));
            sGeo.setAttribute('aRandom', new THREE.Float32BufferAttribute(sRandoms, 1));
            
            const objY = CONFIG.treeHeight + 1.5;
            const galaxyLocalY = 10 - objY;
            addGalaxyAttribute(sGeo, sphereCount, 1.0, galaxyLocalY);

            topStarSpherePoints = new THREE.Points(sGeo, particleMaterial);
            topStarSpherePoints.position.set(0, objY, 0); 
            scene.add(topStarSpherePoints);

            // 2. ÁéØ
            const ringMaterial = particleMaterial.clone();
            ringMaterial.uniforms.uTexture.value = starTexture;

            const createRing = (radius, tiltX, tiltZ) => {
                const rGeo = new THREE.BufferGeometry();
                const rPos = []; const rColors = []; const rSizes = []; const rRandoms = [];
                const ringCount = 400;
                for(let i=0; i<ringCount; i++) {
                    const angle = (i / ringCount) * Math.PI * 2;
                    const scatterR = (Math.random() - 0.5) + (Math.random() - 0.5); 
                    const r = radius + scatterR * 0.5; 
                    let x = Math.cos(angle) * r; let y = (Math.random() - 0.5) * 0.4; let z = Math.sin
